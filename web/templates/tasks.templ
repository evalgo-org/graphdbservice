package templates

type TaskStatus struct {
	Index     int
	Action    string
	Status    string // pending, in-progress, success, error, timeout
	Message   string
	SrcRepo   string
	TgtRepo   string
	SrcGraph  string
	TgtGraph  string
	SrcURL    string
	TgtURL    string
	StartTime string
	EndTime   string
	Duration  string
}

templ TaskResults(sessionID string, tasks []TaskStatus) {
	<div class="card">
		<h2>Task Execution Progress</h2>
		<div id="sse-container" data-session-id={ sessionID }>
			<ul class="task-list" id="task-list">
				for _, task := range tasks {
					@TaskItem(task)
				}
			</ul>
			<div id="execution-summary" class="execution-summary">
				<div><strong>Total Tasks:</strong> <span id="total-tasks">{ string(rune(len(tasks) + 48)) }</span></div>
				<div><strong>Total Time:</strong> <span id="total-time">Calculating...</span></div>
			</div>
		</div>
	</div>
	<script>
		(function() {
			// Close any existing SSE connection before creating a new one
			if (window.currentEventSource) {
				console.log('Closing previous SSE connection');
				window.currentEventSource.close();
				window.currentEventSource = null;
			}

			const container = document.getElementById('sse-container');
			const sessionID = container.getAttribute('data-session-id');
			const eventSource = new EventSource('/ui/stream/' + sessionID);
			const startTime = Date.now();

			// Store in global variable for cleanup
			window.currentEventSource = eventSource;

			console.log('Connecting to SSE stream:', '/ui/stream/' + sessionID);

			// Function to update total execution time
			function updateTotalTime() {
				const tasks = document.querySelectorAll('.task-item');
				let allCompleted = true;
				let totalDuration = 0;

				tasks.forEach(task => {
					const status = task.classList.contains('success') ||
					               task.classList.contains('error') ||
					               task.classList.contains('timeout');
					if (!status) {
						allCompleted = false;
					}
				});

				if (allCompleted) {
					const elapsed = Math.floor((Date.now() - startTime) / 1000);
					document.getElementById('total-time').textContent = formatElapsedTime(elapsed);
				} else {
					const elapsed = Math.floor((Date.now() - startTime) / 1000);
					document.getElementById('total-time').textContent = formatElapsedTime(elapsed) + ' (in progress)';
				}
			}

			function formatElapsedTime(seconds) {
				if (seconds < 60) {
					return seconds + 's';
				}
				const minutes = Math.floor(seconds / 60);
				const secs = seconds % 60;
				if (minutes < 60) {
					return minutes + 'm ' + secs + 's';
				}
				const hours = Math.floor(minutes / 60);
				const mins = minutes % 60;
				return hours + 'h ' + mins + 'm ' + secs + 's';
			}

			// Update total time every second
			const timerInterval = setInterval(updateTotalTime, 1000);

			eventSource.addEventListener('task-update', function(e) {
				console.log('Received task update:', e.data);
				const parser = new DOMParser();
				const doc = parser.parseFromString(e.data, 'text/html');
				const newTask = doc.querySelector('.task-item');

				if (newTask) {
					const taskIndex = newTask.getAttribute('data-index');
					const existingTask = document.querySelector('.task-item[data-index="' + taskIndex + '"]');

					if (existingTask) {
						existingTask.outerHTML = newTask.outerHTML;
						console.log('Updated task at index:', taskIndex);
						updateTotalTime();
					}
				}
			});

			eventSource.onerror = function(e) {
				console.error('SSE Error:', e);
				if (eventSource.readyState === EventSource.CLOSED) {
					console.log('SSE connection closed');
					clearInterval(timerInterval);
				}
			};

			eventSource.onopen = function() {
				console.log('SSE connection opened successfully');
			};

			// Close connection when page is unloaded
			window.addEventListener('beforeunload', function() {
				if (window.currentEventSource) {
					window.currentEventSource.close();
					window.currentEventSource = null;
					clearInterval(timerInterval);
				}
			});
		})();
	</script>
}

templ TaskItem(task TaskStatus) {
	<li class={ "task-item", task.Status } id={ "task-" + string(rune(task.Index)) } data-index={ string(rune(task.Index + 48)) }>
		<div class="task-header">
			<span class="task-action">
				Task { string(rune(task.Index + 49)) }: { task.Action }
			</span>
			<span class={ "task-status", task.Status }>
				if task.Status == "in-progress" {
					<span class="spinner"></span>
				}
				{ task.Status }
			</span>
		</div>

		<div class="task-details">
			if task.SrcURL != "" {
				<div>
					<strong>Source:</strong> { task.SrcURL }
					if task.SrcRepo != "" {
						{ " → " + task.SrcRepo }
						if task.SrcGraph != "" {
							{ " / " + task.SrcGraph }
						}
					}
				</div>
			}
			if task.TgtURL != "" {
				<div>
					<strong>Target:</strong> { task.TgtURL }
					if task.TgtRepo != "" {
						{ " → " + task.TgtRepo }
						if task.TgtGraph != "" {
							{ " / " + task.TgtGraph }
						}
					}
				</div>
			}
			if task.Duration != "" {
				<div>
					<strong>Duration:</strong> { task.Duration }
				</div>
			}
		</div>

		if task.Message != "" {
			<div class="task-message">
				{ task.Message }
			</div>
		}
	</li>
}

templ TaskUpdate(task TaskStatus) {
	@TaskItem(task)
}
